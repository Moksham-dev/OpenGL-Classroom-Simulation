#version 330 core

// Interpolated values from the vertex shaders
in vec2 UV;
in vec3 Position_worldspace;
in vec3 Normal_cameraspace;
in vec3 EyeDirection_cameraspace;
in vec3 Position_cameraspace;
in vec3 Tangent_cameraspace;
in vec3 Bitangent_cameraspace;
in vec3 GouraudColor;

// Output data
layout(location = 0) out vec4 color;

// === UNIFORM CHANGES ===
uniform sampler2D myTextureSampler;
uniform mat4 MV;

uniform mat4 DepthBiasMVPs[9];
uniform sampler2DArrayShadow shadowMapArray;
uniform vec3 ClassroomLightPositions_cameraspace[9];

uniform float fragmentAlpha;
uniform sampler2D NormalTextureSampler;
uniform sampler2D SpecularTextureSampler;
uniform sampler2D SmudgeSampler;
uniform bool bUseNormalMap;
uniform bool bUseSpecularMap;
uniform bool bIsGlass;
uniform int bIsUnlit;
uniform int uShadingModel;

vec2 poissonDisk[16] = vec2[](
    vec2(-0.94201624, -0.39906216),
    vec2(0.94558609, -0.76890725),
    vec2(-0.094184101, -0.92938870),
    vec2(0.34495938, 0.29387760),
    vec2(-0.91588581, 0.45771432),
    vec2(-0.81544232, -0.87912464),
    vec2(-0.38277543, 0.27676845),
    vec2(0.97484398, 0.75648379),
    vec2(0.44323325, -0.97511554),
    vec2(0.53742981, -0.47373420),
    vec2(-0.26496911, -0.41893023),
    vec2(0.79197514, 0.19090188),
    vec2(-0.24188840, 0.99706507),
    vec2(-0.81409955, 0.91437590),
    vec2(0.19984126, 0.78641367),
    vec2(0.14383161, -0.14100790)
);

float random(vec3 seed, int i) {
    vec4 seed4 = vec4(seed, i);
    float dot_product = dot(seed4, vec4(12.9898, 78.233, 45.164, 94.673));
    return fract(sin(dot_product) * 43758.5453);
}

void main() {

    // Light emission properties
    vec3 LED_LightColor = vec3(1.0, 1.0, 1.0);
    float LED_LightPower = 1.25;
    if (bIsUnlit == 1) { color = texture(myTextureSampler, UV); return; }

    // Material properties
    vec3 MaterialDiffuseColor;
    vec3 MaterialAmbientColor;
    vec3 MaterialSpecularColor;
    float currentShininess;
    float factor=1.1;
    float linear = 0.01;
    float quadratic = 0.005;
    float base =1;
	

    if (bIsGlass) {
        float smudgeValue = texture(SmudgeSampler, UV).r;
        float smudgeFactor = smoothstep(0.2, 0.5, smudgeValue);
        MaterialDiffuseColor = vec3(0.1, 0.1, 0.1) * smudgeFactor;
        MaterialAmbientColor = vec3(0.1, 0.1, 0.1);
        MaterialSpecularColor = vec3(mix(1.0, 0.0, smudgeFactor));
        currentShininess = mix(256.0, 10.0, smudgeFactor);
    }
    else {
        MaterialDiffuseColor = texture(myTextureSampler, UV).rgb;
        MaterialAmbientColor = vec3(0.55, 0.55, 0.55) * MaterialDiffuseColor;
        

        if (bUseSpecularMap) {
            MaterialSpecularColor = texture(SpecularTextureSampler, UV).rgb * vec3(0.1,0.1,0.1);
            MaterialAmbientColor = vec3(0.6, 0.6, 0.6) * MaterialDiffuseColor;
            factor=0.04;
            linear=0.007;
            quadratic=0.0007;
            LED_LightPower =10;
            base=5;
        } else {
            MaterialSpecularColor = vec3(0.9, 0.9, 0.9);
        }
        currentShininess = 50.0;
    }
    if (uShadingModel == 1) {
        // Multiply the calculated vertex light intensity by the texture color
        // Note: This applies the light (diffuse+specular calculated in VS) to the texture.
        // For strict accuracy, specular should be separate, but standard Gouraud modulation is this:
        color = vec4(GouraudColor * MaterialDiffuseColor, fragmentAlpha);
    }else{

    // Normal (camera space)
    vec3 n;
    if (bUseNormalMap) {
        vec3 Normal_tangentspace = normalize(texture(NormalTextureSampler, UV).rgb * 2.0 - 1.0);
        vec3 T = normalize(Tangent_cameraspace);
        vec3 B = normalize(Bitangent_cameraspace);
        vec3 N_cam = normalize(Normal_cameraspace);
        mat3 TBN = mat3(T, B, N_cam);
        n = normalize(TBN * Normal_tangentspace);
    } else {
        n = normalize(Normal_cameraspace);
    }

    vec3 E = normalize(EyeDirection_cameraspace);

    vec3 finalColor = MaterialAmbientColor;

    // Loop through all 9 lights
    for (int i = 0; i < 9; i++) {

        vec3 fragmentToLight_cameraspace = ClassroomLightPositions_cameraspace[i] - Position_cameraspace;
        float distance = length(fragmentToLight_cameraspace);
        vec3 l_led = normalize(fragmentToLight_cameraspace);
        vec3 R_led = reflect(-l_led, n);

        float cosTheta_led = clamp(dot(n, l_led), 0.0, 1.0);
        float cosAlpha_led = clamp(dot(E, R_led), 0.0, 1.0);
        // Try "Long" range values
	
	float attenuation = factor / (base + linear * distance + quadratic * distance * distance);
        

        // Shadow
        float shadow = 0.0;
        float bias = 0.010;

        vec4 ShadowCoord_Array = DepthBiasMVPs[i] * vec4(Position_worldspace, 1.0);
        vec3 projCoords = ShadowCoord_Array.xyz / ShadowCoord_Array.w;

        for (int j = 0; j < 4; j++) {
            shadow += texture(
                shadowMapArray,
                vec4(
                    projCoords.xy + poissonDisk[j] / 1024.0,
                    float(i),
                    projCoords.z - bias
                )
            );
        }
        shadow /= 4.0;

        finalColor += shadow * attenuation * LED_LightColor *
            (MaterialDiffuseColor * LED_LightPower * cosTheta_led +
             MaterialSpecularColor * LED_LightPower * pow(cosAlpha_led, currentShininess));

    }

    color = vec4(finalColor, fragmentAlpha);
    }
}

